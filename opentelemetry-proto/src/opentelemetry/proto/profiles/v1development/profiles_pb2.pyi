"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2023, OpenTelemetry Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

This file includes work covered by the following copyright and permission notices:

Copyright 2016 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import opentelemetry.proto.common.v1.common_pb2
import opentelemetry.proto.resource.v1.resource_pb2
import sys

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class ProfilesDictionary(google.protobuf.message.Message):
    """               Relationships Diagram

    ┌──────────────────┐                      LEGEND
    │   ProfilesData   │ ─────┐
    └──────────────────┘      │           ─────▶ embedded
      │                       │
      │ 1-n                   │           ─────▷ referenced by index
      ▼                       ▼
    ┌──────────────────┐   ┌────────────────────┐
    │ ResourceProfiles │   │ ProfilesDictionary │
    └──────────────────┘   └────────────────────┘
      │
      │ 1-n
      ▼
    ┌──────────────────┐
    │  ScopeProfiles   │
    └──────────────────┘
      │
      │ 1-n
      ▼
    ┌──────────────────┐
    │      Profile     │
    └──────────────────┘
      │                                n-1
      │ 1-n         ┌───────────────────────────────────────┐
      ▼             │                                       ▽
    ┌──────────────────┐   1-n   ┌─────────────────┐   ┌──────────┐
    │      Sample      │ ──────▷ │ KeyValueAndUnit │   │   Link   │
    └──────────────────┘         └─────────────────┘   └──────────┘
      │                              △      △
      │ n-1                          │      │ 1-n
      ▽                              │      │
    ┌──────────────────┐             │      │
    │      Stack       │             │      │
    └──────────────────┘             │      │
      │                     1-n      │      │
      │ 1-n         ┌────────────────┘      │
      ▽             │                       │
    ┌──────────────────┐   n-1   ┌─────────────┐
    │     Location     │ ──────▷ │   Mapping   │
    └──────────────────┘         └─────────────┘
      │
      │ 1-n
      ▼
    ┌──────────────────┐
    │       Line       │
    └──────────────────┘
      │
      │ 1-1
      ▽
    ┌──────────────────┐
    │     Function     │
    └──────────────────┘

    ProfilesDictionary represents the profiles data shared across the
    entire message being sent. The following applies to all fields in this
    message:

    - A dictionary is an array of dictionary items. Users of the dictionary
      compactly reference the items using the index within the array.

    - A dictionary MUST have a zero value encoded as the first element. This
      allows for _index fields pointing into the dictionary to use a 0 pointer
      value to indicate 'null' / 'not set'. Unless otherwise defined, a 'zero
      value' message value is one with all default field values, so as to
      minimize wire encoded size.

    - There SHOULD NOT be dupes in a dictionary. The identity of dictionary
      items is based on their value, recursively as needed. If a particular
      implementation does emit duplicated items, it MUST NOT attempt to give them
      meaning based on the index or order. A profile processor may remove
      duplicate items and this MUST NOT have any observable effects for
      consumers.

    - There SHOULD NOT be orphaned (unreferenced) items in a dictionary. A
      profile processor may remove ("garbage-collect") orphaned items and this
      MUST NOT have any observable effects for consumers.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MAPPING_TABLE_FIELD_NUMBER: builtins.int
    LOCATION_TABLE_FIELD_NUMBER: builtins.int
    FUNCTION_TABLE_FIELD_NUMBER: builtins.int
    LINK_TABLE_FIELD_NUMBER: builtins.int
    STRING_TABLE_FIELD_NUMBER: builtins.int
    ATTRIBUTE_TABLE_FIELD_NUMBER: builtins.int
    STACK_TABLE_FIELD_NUMBER: builtins.int
    @property
    def mapping_table(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Mapping]:
        """Mappings from address ranges to the image/binary/library mapped
        into that address range referenced by locations via Location.mapping_index.

        mapping_table[0] must always be zero value (Mapping{}) and present.
        """
    @property
    def location_table(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Location]:
        """Locations referenced by samples via Stack.location_indices.

        location_table[0] must always be zero value (Location{}) and present.
        """
    @property
    def function_table(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Function]:
        """Functions referenced by locations via Line.function_index.

        function_table[0] must always be zero value (Function{}) and present.
        """
    @property
    def link_table(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Link]:
        """Links referenced by samples via Sample.link_index.

        link_table[0] must always be zero value (Link{}) and present.
        """
    @property
    def string_table(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """A common table for strings referenced by various messages.

        string_table[0] must always be "" and present.
        """
    @property
    def attribute_table(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___KeyValueAndUnit]:
        """A common table for attributes referenced by the Profile, Sample, Mapping
        and Location messages below through attribute_indices field. Each entry is
        a key/value pair with an optional unit. Since this is a dictionary table,
        multiple entries with the same key may be present, unlike direct attribute
        tables like Resource.attributes. The referencing attribute_indices fields,
        though, do maintain the key uniqueness requirement.

        It's recommended to use attributes for variables with bounded cardinality,
        such as categorical variables
        (https://en.wikipedia.org/wiki/Categorical_variable). Using an attribute of
        a floating point type (e.g., CPU time) in a sample can quickly make every
        attribute value unique, defeating the purpose of the dictionary and
        impractically increasing the profile size.

        Examples of attributes:
            "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
            "abc.com/myattribute": true
            "allocation_size": 128 bytes

        attribute_table[0] must always be zero value (KeyValueAndUnit{}) and present.
        """
    @property
    def stack_table(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Stack]:
        """Stacks referenced by samples via Sample.stack_index.

        stack_table[0] must always be zero value (Stack{}) and present.
        """
    def __init__(
        self,
        *,
        mapping_table: collections.abc.Iterable[global___Mapping] | None = ...,
        location_table: collections.abc.Iterable[global___Location] | None = ...,
        function_table: collections.abc.Iterable[global___Function] | None = ...,
        link_table: collections.abc.Iterable[global___Link] | None = ...,
        string_table: collections.abc.Iterable[builtins.str] | None = ...,
        attribute_table: collections.abc.Iterable[global___KeyValueAndUnit] | None = ...,
        stack_table: collections.abc.Iterable[global___Stack] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["attribute_table", b"attribute_table", "function_table", b"function_table", "link_table", b"link_table", "location_table", b"location_table", "mapping_table", b"mapping_table", "stack_table", b"stack_table", "string_table", b"string_table"]) -> None: ...

global___ProfilesDictionary = ProfilesDictionary

@typing_extensions.final
class ProfilesData(google.protobuf.message.Message):
    """ProfilesData represents the profiles data that can be stored in persistent storage,
    OR can be embedded by other protocols that transfer OTLP profiles data but do not
    implement the OTLP protocol.

    The main difference between this message and collector protocol is that
    in this message there will not be any "control" or "metadata" specific to
    OTLP protocol.

    When new fields are added into this message, the OTLP request MUST be updated
    as well.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESOURCE_PROFILES_FIELD_NUMBER: builtins.int
    DICTIONARY_FIELD_NUMBER: builtins.int
    @property
    def resource_profiles(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ResourceProfiles]:
        """An array of ResourceProfiles.
        For data coming from an SDK profiler, this array will typically contain one
        element. Host-level profilers will usually create one ResourceProfile per
        container, as well as one additional ResourceProfile grouping all samples
        from non-containerized processes.
        Other resource groupings are possible as well and clarified via
        Resource.attributes and semantic conventions.
        Tools that visualize profiles should prefer displaying
        resources_profiles[0].scope_profiles[0].profiles[0] by default.
        """
    @property
    def dictionary(self) -> global___ProfilesDictionary:
        """One instance of ProfilesDictionary"""
    def __init__(
        self,
        *,
        resource_profiles: collections.abc.Iterable[global___ResourceProfiles] | None = ...,
        dictionary: global___ProfilesDictionary | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["dictionary", b"dictionary"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dictionary", b"dictionary", "resource_profiles", b"resource_profiles"]) -> None: ...

global___ProfilesData = ProfilesData

@typing_extensions.final
class ResourceProfiles(google.protobuf.message.Message):
    """A collection of ScopeProfiles from a Resource."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESOURCE_FIELD_NUMBER: builtins.int
    SCOPE_PROFILES_FIELD_NUMBER: builtins.int
    SCHEMA_URL_FIELD_NUMBER: builtins.int
    @property
    def resource(self) -> opentelemetry.proto.resource.v1.resource_pb2.Resource:
        """The resource for the profiles in this message.
        If this field is not set then no resource info is known.
        """
    @property
    def scope_profiles(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ScopeProfiles]:
        """A list of ScopeProfiles that originate from a resource."""
    schema_url: builtins.str
    """The Schema URL, if known. This is the identifier of the Schema that the resource data
    is recorded in. Notably, the last part of the URL path is the version number of the
    schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
    https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
    This schema_url applies to the data in the "resource" field. It does not apply
    to the data in the "scope_profiles" field which have their own schema_url field.
    """
    def __init__(
        self,
        *,
        resource: opentelemetry.proto.resource.v1.resource_pb2.Resource | None = ...,
        scope_profiles: collections.abc.Iterable[global___ScopeProfiles] | None = ...,
        schema_url: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["resource", b"resource"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["resource", b"resource", "schema_url", b"schema_url", "scope_profiles", b"scope_profiles"]) -> None: ...

global___ResourceProfiles = ResourceProfiles

@typing_extensions.final
class ScopeProfiles(google.protobuf.message.Message):
    """A collection of Profiles produced by an InstrumentationScope."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SCOPE_FIELD_NUMBER: builtins.int
    PROFILES_FIELD_NUMBER: builtins.int
    SCHEMA_URL_FIELD_NUMBER: builtins.int
    @property
    def scope(self) -> opentelemetry.proto.common.v1.common_pb2.InstrumentationScope:
        """The instrumentation scope information for the profiles in this message.
        Semantically when InstrumentationScope isn't set, it is equivalent with
        an empty instrumentation scope name (unknown).
        """
    @property
    def profiles(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Profile]:
        """A list of Profiles that originate from an instrumentation scope."""
    schema_url: builtins.str
    """The Schema URL, if known. This is the identifier of the Schema that the profile data
    is recorded in. Notably, the last part of the URL path is the version number of the
    schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
    https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
    This schema_url applies to the data in the "scope" field and all profiles in the
    "profiles" field.
    """
    def __init__(
        self,
        *,
        scope: opentelemetry.proto.common.v1.common_pb2.InstrumentationScope | None = ...,
        profiles: collections.abc.Iterable[global___Profile] | None = ...,
        schema_url: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["scope", b"scope"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["profiles", b"profiles", "schema_url", b"schema_url", "scope", b"scope"]) -> None: ...

global___ScopeProfiles = ScopeProfiles

@typing_extensions.final
class Profile(google.protobuf.message.Message):
    """Profile is a common stacktrace profile format.

    Measurements represented with this format should follow the
    following conventions:

    - Consumers should treat unset optional fields as if they had been
      set with their default value.

    - When possible, measurements should be stored in "unsampled" form
      that is most useful to humans.  There should be enough
      information present to determine the original sampled values.

    - The profile is represented as a set of samples, where each sample
      references a stack trace which is a list of locations, each belonging
      to a mapping.
    - There is a N->1 relationship from Stack.location_indices entries to
      locations. For every Stack.location_indices entry there must be a
      unique Location with that index.
    - There is an optional N->1 relationship from locations to
      mappings. For every nonzero Location.mapping_id there must be a
      unique Mapping with that index.

    Represents a complete profile, including sample types, samples, mappings to
    binaries, stacks, locations, functions, string table, and additional
    metadata. It modifies and annotates pprof Profile with OpenTelemetry
    specific fields.

    Note that whilst fields in this message retain the name and field id from pprof in most cases
    for ease of understanding data migration, it is not intended that pprof:Profile and
    OpenTelemetry:Profile encoding be wire compatible.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SAMPLE_TYPE_FIELD_NUMBER: builtins.int
    SAMPLES_FIELD_NUMBER: builtins.int
    TIME_UNIX_NANO_FIELD_NUMBER: builtins.int
    DURATION_NANO_FIELD_NUMBER: builtins.int
    PERIOD_TYPE_FIELD_NUMBER: builtins.int
    PERIOD_FIELD_NUMBER: builtins.int
    PROFILE_ID_FIELD_NUMBER: builtins.int
    DROPPED_ATTRIBUTES_COUNT_FIELD_NUMBER: builtins.int
    ORIGINAL_PAYLOAD_FORMAT_FIELD_NUMBER: builtins.int
    ORIGINAL_PAYLOAD_FIELD_NUMBER: builtins.int
    ATTRIBUTE_INDICES_FIELD_NUMBER: builtins.int
    @property
    def sample_type(self) -> global___ValueType:
        """The type and unit of all Sample.values in this profile.
        For a cpu or off-cpu profile this might be:
          ["cpu","nanoseconds"] or ["off_cpu","nanoseconds"]
        For a heap profile, this might be:
          ["allocated_objects","count"] or ["allocated_space","bytes"],
        """
    @property
    def samples(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Sample]:
        """The set of samples recorded in this profile."""
    time_unix_nano: builtins.int
    """The following fields 3-12 are informational, do not affect
    interpretation of results.

    Time of collection (UTC) represented as nanoseconds past the epoch.
    """
    duration_nano: builtins.int
    """Duration of the profile, if a duration makes sense."""
    @property
    def period_type(self) -> global___ValueType:
        """The kind of events between sampled occurrences.
        e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
        """
    period: builtins.int
    """The number of events between sampled occurrences."""
    profile_id: builtins.bytes
    """A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
    all zeroes is considered invalid. It may be used for deduplication and signal
    correlation purposes. It is acceptable to treat two profiles with different values
    in this field as not equal, even if they represented the same object at an earlier
    time.
    This field is optional; an ID may be assigned to an ID-less profile in a later step.
    """
    dropped_attributes_count: builtins.int
    """The number of attributes that were discarded. Attributes
    can be discarded because their keys are too long or because there are too many
    attributes. If this value is 0, then no attributes were dropped.
    """
    original_payload_format: builtins.str
    """The original payload format. See also original_payload. Optional, but the
    format and the bytes must be set or unset together.

    The allowed values for the format string are defined by the OpenTelemetry
    specification. Some examples are "jfr", "pprof", "linux_perf".

    The original payload may be optionally provided when the conversion to the
    OLTP format was done from a different format with some loss of the fidelity
    and the receiver may want to store the original payload to allow future
    lossless export or reinterpretation. Some examples of the original format
    are JFR (Java Flight Recorder), pprof, Linux perf.

    Even when the original payload is in a format that is semantically close to
    OTLP, such as pprof, a conversion may still be lossy in some cases (e.g. if
    the pprof file contains custom extensions or conventions).

    The original payload can be large in size, so including the original
    payload should be configurable by the profiler or collector options. The
    default behavior should be to not include the original payload.
    """
    original_payload: builtins.bytes
    """The original payload bytes. See also original_payload_format. Optional, but
    format and the bytes must be set or unset together.
    """
    @property
    def attribute_indices(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """References to attributes in attribute_table. [optional]"""
    def __init__(
        self,
        *,
        sample_type: global___ValueType | None = ...,
        samples: collections.abc.Iterable[global___Sample] | None = ...,
        time_unix_nano: builtins.int = ...,
        duration_nano: builtins.int = ...,
        period_type: global___ValueType | None = ...,
        period: builtins.int = ...,
        profile_id: builtins.bytes = ...,
        dropped_attributes_count: builtins.int = ...,
        original_payload_format: builtins.str = ...,
        original_payload: builtins.bytes = ...,
        attribute_indices: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["period_type", b"period_type", "sample_type", b"sample_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["attribute_indices", b"attribute_indices", "dropped_attributes_count", b"dropped_attributes_count", "duration_nano", b"duration_nano", "original_payload", b"original_payload", "original_payload_format", b"original_payload_format", "period", b"period", "period_type", b"period_type", "profile_id", b"profile_id", "sample_type", b"sample_type", "samples", b"samples", "time_unix_nano", b"time_unix_nano"]) -> None: ...

global___Profile = Profile

@typing_extensions.final
class Link(google.protobuf.message.Message):
    """A pointer from a profile Sample to a trace Span.
    Connects a profile sample to a trace span, identified by unique trace and span IDs.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TRACE_ID_FIELD_NUMBER: builtins.int
    SPAN_ID_FIELD_NUMBER: builtins.int
    trace_id: builtins.bytes
    """A unique identifier of a trace that this linked span is part of. The ID is a
    16-byte array.
    """
    span_id: builtins.bytes
    """A unique identifier for the linked span. The ID is an 8-byte array."""
    def __init__(
        self,
        *,
        trace_id: builtins.bytes = ...,
        span_id: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["span_id", b"span_id", "trace_id", b"trace_id"]) -> None: ...

global___Link = Link

@typing_extensions.final
class ValueType(google.protobuf.message.Message):
    """ValueType describes the type and units of a value."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_STRINDEX_FIELD_NUMBER: builtins.int
    UNIT_STRINDEX_FIELD_NUMBER: builtins.int
    type_strindex: builtins.int
    """Index into ProfilesDictionary.string_table."""
    unit_strindex: builtins.int
    """Index into ProfilesDictionary.string_table."""
    def __init__(
        self,
        *,
        type_strindex: builtins.int = ...,
        unit_strindex: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["type_strindex", b"type_strindex", "unit_strindex", b"unit_strindex"]) -> None: ...

global___ValueType = ValueType

@typing_extensions.final
class Sample(google.protobuf.message.Message):
    """Each Sample records values encountered in some program context. The program
    context is typically a stack trace, perhaps augmented with auxiliary
    information like the thread-id, some indicator of a higher level request
    being handled etc.

    A Sample MUST have have at least one values or timestamps_unix_nano entry. If
    both fields are populated, they MUST contain the same number of elements, and
    the elements at the same index MUST refer to the same event.

    Examples of different ways of representing a sample with the total value of 10:

    Report of a stacktrace at 10 timestamps (consumers must assume the value is 1 for each point):
       values: []
       timestamps_unix_nano: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    Report of a stacktrace with an aggregated value without timestamps:
      values: [10]
       timestamps_unix_nano: []

    Report of a stacktrace at 4 timestamps where each point records a specific value:
       values: [2, 2, 3, 3]
       timestamps_unix_nano: [1, 2, 3, 4]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STACK_INDEX_FIELD_NUMBER: builtins.int
    VALUES_FIELD_NUMBER: builtins.int
    ATTRIBUTE_INDICES_FIELD_NUMBER: builtins.int
    LINK_INDEX_FIELD_NUMBER: builtins.int
    TIMESTAMPS_UNIX_NANO_FIELD_NUMBER: builtins.int
    stack_index: builtins.int
    """Reference to stack in ProfilesDictionary.stack_table."""
    @property
    def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """The type and unit of each value is defined by Profile.sample_type."""
    @property
    def attribute_indices(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """References to attributes in ProfilesDictionary.attribute_table. [optional]"""
    link_index: builtins.int
    """Reference to link in ProfilesDictionary.link_table. [optional]
    It can be unset / set to 0 if no link exists, as link_table[0] is always a 'null' default value.
    """
    @property
    def timestamps_unix_nano(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Timestamps associated with Sample represented in nanoseconds. These
        timestamps should fall within the Profile's time range.
        """
    def __init__(
        self,
        *,
        stack_index: builtins.int = ...,
        values: collections.abc.Iterable[builtins.int] | None = ...,
        attribute_indices: collections.abc.Iterable[builtins.int] | None = ...,
        link_index: builtins.int = ...,
        timestamps_unix_nano: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["attribute_indices", b"attribute_indices", "link_index", b"link_index", "stack_index", b"stack_index", "timestamps_unix_nano", b"timestamps_unix_nano", "values", b"values"]) -> None: ...

global___Sample = Sample

@typing_extensions.final
class Mapping(google.protobuf.message.Message):
    """Describes the mapping of a binary in memory, including its address range,
    file offset, and metadata like build ID
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MEMORY_START_FIELD_NUMBER: builtins.int
    MEMORY_LIMIT_FIELD_NUMBER: builtins.int
    FILE_OFFSET_FIELD_NUMBER: builtins.int
    FILENAME_STRINDEX_FIELD_NUMBER: builtins.int
    ATTRIBUTE_INDICES_FIELD_NUMBER: builtins.int
    memory_start: builtins.int
    """Address at which the binary (or DLL) is loaded into memory."""
    memory_limit: builtins.int
    """The limit of the address range occupied by this mapping."""
    file_offset: builtins.int
    """Offset in the binary that corresponds to the first mapped address."""
    filename_strindex: builtins.int
    """The object this entry is loaded from.  This can be a filename on
    disk for the main binary and shared libraries, or virtual
    abstractions like "[vdso]".
    Index into ProfilesDictionary.string_table.
    """
    @property
    def attribute_indices(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """References to attributes in ProfilesDictionary.attribute_table. [optional]"""
    def __init__(
        self,
        *,
        memory_start: builtins.int = ...,
        memory_limit: builtins.int = ...,
        file_offset: builtins.int = ...,
        filename_strindex: builtins.int = ...,
        attribute_indices: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["attribute_indices", b"attribute_indices", "file_offset", b"file_offset", "filename_strindex", b"filename_strindex", "memory_limit", b"memory_limit", "memory_start", b"memory_start"]) -> None: ...

global___Mapping = Mapping

@typing_extensions.final
class Stack(google.protobuf.message.Message):
    """A Stack represents a stack trace as a list of locations."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LOCATION_INDICES_FIELD_NUMBER: builtins.int
    @property
    def location_indices(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """References to locations in ProfilesDictionary.location_table.
        The first location is the leaf frame.
        """
    def __init__(
        self,
        *,
        location_indices: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["location_indices", b"location_indices"]) -> None: ...

global___Stack = Stack

@typing_extensions.final
class Location(google.protobuf.message.Message):
    """Describes function and line table debug information."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MAPPING_INDEX_FIELD_NUMBER: builtins.int
    ADDRESS_FIELD_NUMBER: builtins.int
    LINES_FIELD_NUMBER: builtins.int
    ATTRIBUTE_INDICES_FIELD_NUMBER: builtins.int
    mapping_index: builtins.int
    """Reference to mapping in ProfilesDictionary.mapping_table.
    It can be unset / set to 0 if the mapping is unknown or not applicable for
    this profile type, as mapping_table[0] is always a 'null' default mapping.
    """
    address: builtins.int
    """The instruction address for this location, if available.  It
    should be within [Mapping.memory_start...Mapping.memory_limit]
    for the corresponding mapping. A non-leaf address may be in the
    middle of a call instruction. It is up to display tools to find
    the beginning of the instruction if necessary.
    """
    @property
    def lines(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Line]:
        """Multiple line indicates this location has inlined functions,
        where the last entry represents the caller into which the
        preceding entries were inlined.

        E.g., if memcpy() is inlined into printf:
           lines[0].function_name == "memcpy"
           lines[1].function_name == "printf"
        """
    @property
    def attribute_indices(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """References to attributes in ProfilesDictionary.attribute_table. [optional]"""
    def __init__(
        self,
        *,
        mapping_index: builtins.int = ...,
        address: builtins.int = ...,
        lines: collections.abc.Iterable[global___Line] | None = ...,
        attribute_indices: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["address", b"address", "attribute_indices", b"attribute_indices", "lines", b"lines", "mapping_index", b"mapping_index"]) -> None: ...

global___Location = Location

@typing_extensions.final
class Line(google.protobuf.message.Message):
    """Details a specific line in a source code, linked to a function."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FUNCTION_INDEX_FIELD_NUMBER: builtins.int
    LINE_FIELD_NUMBER: builtins.int
    COLUMN_FIELD_NUMBER: builtins.int
    function_index: builtins.int
    """Reference to function in ProfilesDictionary.function_table."""
    line: builtins.int
    """Line number in source code. 0 means unset."""
    column: builtins.int
    """Column number in source code. 0 means unset."""
    def __init__(
        self,
        *,
        function_index: builtins.int = ...,
        line: builtins.int = ...,
        column: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["column", b"column", "function_index", b"function_index", "line", b"line"]) -> None: ...

global___Line = Line

@typing_extensions.final
class Function(google.protobuf.message.Message):
    """Describes a function, including its human-readable name, system name,
    source file, and starting line number in the source.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_STRINDEX_FIELD_NUMBER: builtins.int
    SYSTEM_NAME_STRINDEX_FIELD_NUMBER: builtins.int
    FILENAME_STRINDEX_FIELD_NUMBER: builtins.int
    START_LINE_FIELD_NUMBER: builtins.int
    name_strindex: builtins.int
    """The function name. Empty string if not available."""
    system_name_strindex: builtins.int
    """Function name, as identified by the system. For instance,
    it can be a C++ mangled name. Empty string if not available.
    """
    filename_strindex: builtins.int
    """Source file containing the function. Empty string if not available."""
    start_line: builtins.int
    """Line number in source file. 0 means unset."""
    def __init__(
        self,
        *,
        name_strindex: builtins.int = ...,
        system_name_strindex: builtins.int = ...,
        filename_strindex: builtins.int = ...,
        start_line: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["filename_strindex", b"filename_strindex", "name_strindex", b"name_strindex", "start_line", b"start_line", "system_name_strindex", b"system_name_strindex"]) -> None: ...

global___Function = Function

@typing_extensions.final
class KeyValueAndUnit(google.protobuf.message.Message):
    """A custom 'dictionary native' style of encoding attributes which is more convenient
    for profiles than opentelemetry.proto.common.v1.KeyValue
    Specifically, uses the string table for keys and allows optional unit information.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_STRINDEX_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    UNIT_STRINDEX_FIELD_NUMBER: builtins.int
    key_strindex: builtins.int
    """The index into the string table for the attribute's key."""
    @property
    def value(self) -> opentelemetry.proto.common.v1.common_pb2.AnyValue:
        """The value of the attribute."""
    unit_strindex: builtins.int
    """The index into the string table for the attribute's unit.
    zero indicates implicit (by semconv) or non-defined unit.
    """
    def __init__(
        self,
        *,
        key_strindex: builtins.int = ...,
        value: opentelemetry.proto.common.v1.common_pb2.AnyValue | None = ...,
        unit_strindex: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["key_strindex", b"key_strindex", "unit_strindex", b"unit_strindex", "value", b"value"]) -> None: ...

global___KeyValueAndUnit = KeyValueAndUnit
